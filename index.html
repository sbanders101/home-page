<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Natural Cycles</title>
  <style>
    /* Ensure the page fills the viewport */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    /* Background halves */
    #sky, #earth {
      position: absolute;
      left: 0;
      width: 100%;
      z-index: 0;
    }
    #sky {
      top: 0;
      height: 50%;
      background-color: #D2EEFF; /* fallback winter sky */
    }
    #earth {
      bottom: 0;
      height: 50%;
      background-color: #EDF9FF; /* fallback winter earth */
    }
    /* Time display on top */
    #timeDisplay {
      position: fixed;           /* So it stays at the bottom even when scrolling */
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 10px 20px;        /* Adds a 20px margin on either side via padding */
      text-align: center;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      color: #fff;
      z-index: 2;
      box-sizing: border-box;    /* Ensures padding doesn't cause overflow */

      /* The magic: use vw so font scales with viewport width */
      font-size: 10vw;     /* Adjust number to taste (e.g. 8vw, 5vw, etc.) */
      line-height: 1;      /* Keep lines tight if it wraps */
      white-space: nowrap; /* Prevent multiple lines if it gets big */
      overflow: hidden;    /* Hide overflow if it’s too big */
    }
    /* The canvas for our circle fills the viewport and is above backgrounds */
    #sunCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="sky"></div>
  <div id="earth"></div>
  
  <!-- The canvas that renders the day (white) / night (black) wedges -->
  <canvas id="sunCanvas"></canvas>
  
  <div id="timeDisplay"></div>

  <script>
    // === CONFIGURATION ===
    const DAY_WEDGE_COLOR = 'rgba(255,255,255,0.15)';
    const NIGHT_WEDGE_COLOR = 'rgba(0,0,0,0.1)';
    const CIVIL_WEDGE_COLOR = 'rgba(0,0,0,0.05)';
    const DEFAULT_LAT = 40.7128;   // New York lat
    const DEFAULT_LON = -74.0060;  // New York lon

    // Seasonal colors for the (Northern Hemisphere) checkpoints
    const SEASON_COLORS = {
      winter: { sky: '#D2EEFF', earth: '#EDF9FF' },  // January 15
      spring: { sky: '#D4FCF2', earth: '#B1F6BE' },  // April 15
      summer: { sky: '#A6F7E1', earth: '#67E9A7' },  // July 15
      autumn: { sky: '#FFDACA', earth: '#FFA558' }   // October 15
    };

    // Global sunrise/sunset variables
    let sunriseTime = null;
    let sunsetTime = null;

    function hoursSinceMidnight(date) {
      return date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
    }

    // --- INITIALIZATION ---
    function init() {
      // Try to get the user’s location; if unavailable, use defaults.
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            fetchSunTimes(position.coords.latitude, position.coords.longitude);
          },
          (err) => {
            console.warn('Geolocation failed, defaulting to New York coordinates.', err);
            fetchSunTimes(DEFAULT_LAT, DEFAULT_LON);
          }
        );
      } else {
        console.warn('Geolocation not supported, defaulting to New York coordinates.');
        fetchSunTimes(DEFAULT_LAT, DEFAULT_LON);
      }
      
      // Start updating the display once per second
      setInterval(updateDisplay, 1000);
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
    }

    // --- FETCH SUNRISE/SUNSET TIMES ---
    function fetchSunTimes(lat, lon) {
      // The API returns times in UTC; we assume local conversion on Date() is acceptable here.
      const url = `https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&formatted=0`;
      fetch(url)
        .then(response => response.json())
        .then(data => {
          // Parse the returned ISO strings into Date objects.
          sunriseTime = new Date(data.results.sunrise);
          sunsetTime  = new Date(data.results.sunset);
          civilTwilightBeginTime = new Date(data.results.civil_twilight_begin);
          civilTwilightEndTime   = new Date(data.results.civil_twilight_end);
        })
        .catch(err => {
          console.warn('Failed to fetch sunrise/sunset data; defaulting to a 12h day.', err);
          sunriseTime = null;
          sunsetTime  = null;
          civilTwilightBeginTime = null;
          civilTwilightEndTime   = null;
        });
    }

    // --- UPDATE THE DISPLAY (time, seasonal colors, circle) ---
    function updateDisplay() {
      const now = new Date();
      updateTimeDisplay(now);
      updateSeasonalBackgrounds(now);
      drawSunCircle(now);
    }

    function updateTimeDisplay(now) {
      // Get the last two digits of the year.
      const yearShort = String(now.getFullYear()).slice(-2);
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day   = String(now.getDate()).padStart(2, '0');
      const hours = String(now.getHours()).padStart(2, '0');
      const mins  = String(now.getMinutes()).padStart(2, '0');
      
      document.getElementById('timeDisplay').textContent =
        `${yearShort} . ${month} . ${day} . ${hours} . ${mins}`;
    }

    // Update the sky and earth colors based on the current date
    function updateSeasonalBackgrounds(now) {
      const { skyColor, earthColor } = getSeasonalColors(now);
  
      // Calculate how dark it should be right now
      const twilightFactor = getTwilightDarkeningFactor(now);

      // Interpolate both sky and earth colors toward near-black
      const skyDark = darkenRGBToBlack(skyColor, twilightFactor);
      const earthDark = darkenRGBToBlack(earthColor, twilightFactor);

      // For extra effect, you can still do a gradient that darkens more at the top/bottom
      const skyDarker   = darkenRGBToBlack(skyDark, 0.15);
      const earthDarker = darkenRGBToBlack(earthDark, 0.15);

      // Apply
      document.getElementById('sky').style.background =
        `linear-gradient(to bottom, ${skyDarker}, ${skyDark})`;

      document.getElementById('earth').style.background =
        `linear-gradient(to bottom, ${earthDark}, ${earthDarker})`;
    }

    // --- DRAW THE DAY/NIGHT CIRCLE ---
    function drawSunCircle(now) {
      const canvas = document.getElementById('sunCanvas');
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // Determine the circle's center and radius.
      const radius = Math.min(w, h) * 0.4;
      const centerX = w / 2;
      const centerY = h / 2;

      // Use fallback times if any of the twilight or sun times are missing.
      // Fallback: sunrise at 6:00, sunset at 18:00, civil dawn at 5:30, and civil dusk at 18:30.
      let srH = 6.0, ssH = 18.0, ctbH = 5.5, cteH = 18.5;
      if (sunriseTime && sunsetTime && civilTwilightBeginTime && civilTwilightEndTime) {
        srH = hoursSinceMidnight(sunriseTime);
        ssH = hoursSinceMidnight(sunsetTime);
        ctbH = hoursSinceMidnight(civilTwilightBeginTime);
        cteH = hoursSinceMidnight(civilTwilightEndTime);
      }

      // Helper: Convert hours (0–24) into an angle (0–2π radians).
      function hoursToAngle(hours) {
        return (hours / 24) * 2 * Math.PI;
      }
      const srAngle  = hoursToAngle(srH);
      const ssAngle  = hoursToAngle(ssH);
      const ctbAngle = hoursToAngle(ctbH);
      const cteAngle = hoursToAngle(cteH);

      // We rotate the entire circle so that sunrise is at 0 radians.
      const rotation = -srAngle;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(rotation);

      // --- Draw the four wedges ---

      // 1. Dawn wedge: from civil twilight begin (CTB) to sunrise.
      //    Note: since we rotated by -srAngle, sunrise is at 0.
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, ctbAngle - srAngle, 0, false);
      ctx.closePath();
      ctx.fillStyle = CIVIL_WEDGE_COLOR;
      ctx.fill();

      // 2. Day wedge: from sunrise (0) to sunset.
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, 0, ssAngle - srAngle, false);
      ctx.closePath();
      ctx.fillStyle = DAY_WEDGE_COLOR;
      ctx.fill();

      // 3. Dusk wedge: from sunset to civil twilight end.
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, ssAngle - srAngle, cteAngle - srAngle, false);
      ctx.closePath();
      ctx.fillStyle = CIVIL_WEDGE_COLOR;
      ctx.fill();

      // 4. Night wedge: from civil twilight end to next day’s dawn.
      //    We add 2π to the CTB angle so the arc correctly wraps around.
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, cteAngle - srAngle, (ctbAngle + 2 * Math.PI) - srAngle, false);
      ctx.closePath();
      ctx.fillStyle = NIGHT_WEDGE_COLOR;
      ctx.fill();

      ctx.restore();
    }

    // --- SEASONAL COLOR CALCULATION ---
    // Returns an object { skyColor, earthColor } based on the current date.
    function getSeasonalColors(dateObj) {
  const year = dateObj.getFullYear();

  // Define anchor points using meteorological midpoints.
  // For dates before January 15, we use last year’s autumn as the starting point.
  const autumnPrev = {
    sky: SEASON_COLORS.autumn.sky,
    earth: SEASON_COLORS.autumn.earth,
    fullDate: new Date(`${year - 1}-10-15`)
  };

  const winter = {
    sky: SEASON_COLORS.winter.sky,
    earth: SEASON_COLORS.winter.earth,
    fullDate: new Date(`${year}-01-15`)
  };

  const spring = {
    sky: SEASON_COLORS.spring.sky,
    earth: SEASON_COLORS.spring.earth,
    fullDate: new Date(`${year}-04-15`)
  };

  const summer = {
    sky: SEASON_COLORS.summer.sky,
    earth: SEASON_COLORS.summer.earth,
    fullDate: new Date(`${year}-07-15`)
  };

  const autumn = {
    sky: SEASON_COLORS.autumn.sky,
    earth: SEASON_COLORS.autumn.earth,
    fullDate: new Date(`${year}-10-15`)
  };

  // For dates after October 15, we interpolate toward next winter's peak.
  const winterNext = {
    sky: SEASON_COLORS.winter.sky,
    earth: SEASON_COLORS.winter.earth,
    fullDate: new Date(`${year + 1}-01-15`)
  };

  // Determine between which two checkpoints the current date falls:
  let cp;
  if (dateObj < winter.fullDate) {
    // For dates before January 15, interpolate from last autumn to this winter.
    cp = { start: autumnPrev, end: winter };
  } else if (dateObj < spring.fullDate) {
    cp = { start: winter, end: spring };
  } else if (dateObj < summer.fullDate) {
    cp = { start: spring, end: summer };
  } else if (dateObj < autumn.fullDate) {
    cp = { start: summer, end: autumn };
  } else {
    // For dates on/after October 15, interpolate from autumn to next winter.
    cp = { start: autumn, end: winterNext };
  }

  const range = cp.end.fullDate - cp.start.fullDate;
  const progress = (dateObj - cp.start.fullDate) / range;

  const skyColor = interpolateColor(cp.start.sky, cp.end.sky, progress);
  const earthColor = interpolateColor(cp.start.earth, cp.end.earth, progress);

  return { skyColor, earthColor };
}

    // Linear interpolation between two hex colors.
    function interpolateColor(hex1, hex2, t) {
      // Remove the '#' if present.
      hex1 = hex1.replace('#', '');
      hex2 = hex2.replace('#', '');
      // Parse r, g, b values.
      const r1 = parseInt(hex1.substr(0,2), 16),
            g1 = parseInt(hex1.substr(2,2), 16),
            b1 = parseInt(hex1.substr(4,2), 16);
      const r2 = parseInt(hex2.substr(0,2), 16),
            g2 = parseInt(hex2.substr(2,2), 16),
            b2 = parseInt(hex2.substr(4,2), 16);
      // Interpolate each component.
      const r = Math.round(r1 + (r2 - r1) * t);
      const g = Math.round(g1 + (g2 - g1) * t);
      const b = Math.round(b1 + (b2 - b1) * t);
      return `rgb(${r}, ${g}, ${b})`;
    }

    // This function expects an rgb string like "rgb(210, 238, 255)"
    function darkenRGB(rgbString, factor) {
      // Extract the numeric components from the string.
      let parts = rgbString.match(/\d+/g);
      if (!parts) return rgbString;
      let r = Math.floor(parseInt(parts[0], 10) * factor);
      let g = Math.floor(parseInt(parts[1], 10) * factor);
      let b = Math.floor(parseInt(parts[2], 10) * factor);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function getTwilightDarkeningFactor(now) {
      if (!sunriseTime || !sunsetTime || !civilTwilightBeginTime || !civilTwilightEndTime) {
        return 0; // fallback: always day if times missing
      }

      const nowH = hoursSinceMidnight(now);
      const sr  = hoursSinceMidnight(sunriseTime);
      const ss  = hoursSinceMidnight(sunsetTime);
      const ctb = hoursSinceMidnight(civilTwilightBeginTime);
      const cte = hoursSinceMidnight(civilTwilightEndTime);

      // If it's strictly daytime
      if (nowH >= sr && nowH <= ss) {
        return 0; // fully bright
      }

      // Dusk: sunset → civil twilight end
      if (nowH >= ss && nowH < cte) {
        const fraction = (nowH - ss) / (cte - ss);
        return fraction; // goes from 0 at sunset to 1 at cte
      }

      // Night: cte → next day’s ctb
      if (nowH >= cte && nowH < ctb + 24) {
        // might need to handle midnight wrap properly, but let's keep it simple
        return 1;
      }

      // Dawn: ctb → sunrise
      if (nowH >= ctb && nowH < sr) {
        const fraction = (nowH - ctb) / (sr - ctb);
        return 1 - fraction; // goes from 1 at ctb to 0 at sr
      }

      // Fallback (wrap-around, etc.)
      return 1;
    }

    function darkenRGBToBlack(rgbString, factor) {
      // factor=0 => no darkening; factor=1 => near black
      // Maybe only go 90% black if you want some horizon visibility
      const maxDark = 0.9; 
      const actual = factor * maxDark;

      let parts = rgbString.match(/\d+/g);
      if (!parts) return rgbString;
      let r = parseInt(parts[0], 10);
      let g = parseInt(parts[1], 10);
      let b = parseInt(parts[2], 10);
      
      r = Math.floor(r * (1 - actual));
      g = Math.floor(g * (1 - actual));
      b = Math.floor(b * (1 - actual));
      return `rgb(${r}, ${g}, ${b})`;
    }

    // --- HANDLE CANVAS RESIZING ---
    function resizeCanvas() {
      const canvas = document.getElementById('sunCanvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    // --- START THE APP ---
    init();

    document.addEventListener('keydown', (event) => {
      // Check if the 't' or 'T' key is pressed
      if (event.key.toLowerCase() === 't') {
        const timeDisplay = document.getElementById('timeDisplay');
        // Toggle the element's visibility
        if (timeDisplay.style.display === 'none') {
          timeDisplay.style.display = '';
        } else {
          timeDisplay.style.display = 'none';
        }
      }
    });
  </script>
</body>
</html>
